# 语言设计就是库设计

如果你的库提供了一个字符串类，用户应该不知道、甚至毫不在意字符串在内部到底被表示为指向null结尾的字符数组指针，还是被表示为（计数、地址）对，或者完全是某种其它的方式表示的。换句话说 **设计一个好的程序库的要求之一就是彻底隔离接口的实现**。

‍

## 抽象数据类型

**构造函数与析构函数**

构造函数隐藏了创建对象的细节，析构函数隐藏了销毁对象的细节。两者正是C++中将接口和实现分隔开来的最直接体现。

‍

**成员函数及可见度控制**

通过`public`、`private`、`protected`、`friend`等权限的管理可以更好的隐藏类的实现，而只对外保留类的行为。

‍

## 库与抽象数据类型

**类型安全的链接**

C++支持函数参数的隐式重载，对于不同参数的同名函数可以做到正确的区分。

C语言不支持函数参数的隐式重载，所以当C++使用C代码的函数时依旧有问题，但引进一个新的声明语法就能解决这个问题，例如：

```cpp
extern "C" double sqrt(double);
```

通过`extern "C"`的声明，在链接时，`sqrt(double)`将被是为C函数来处理。

在绝大多数情况下，库设计者不再担心自己函数的名字是否会和其他库里的函数名冲突。而且在不同的编译单元直接进行类型检查时可以提高效率。

‍

**命名空间**

本质上，命名空间允许库设计者对会被库放到全局作用域的所有名称制定一个包装器。用户可以通过使用命名空间表示的名字或从一个命名空间引入所有名字到程序中。

‍

## 内存分配

内存分配的两种方式：

通过调用对象的new来分配内存，而通过调用delete来释放内存：

```cpp
class Foo{
public:
    void* operator new(size_t);
    void operator delete(void*);
};

int function(){
    void* example = Foo::operator new(n);
    Foo::operator delete(example);
}
```

‍

先分配一大块内存，并在这块内存的已知位置放入对象：

```cpp
void* p = new Space();
T* tp = new(p) T; // new(p) T即要求在p指向的内存中分配一个T对象
```

‍

## 按成员赋值和初始化

对于一个类中成员的初始化，并不像C语言中默认复制底层的C结构体。而是自动的获取各个底层类的成员的赋值和赋值的定义，以及所继承的类中的构造函数和析构函数。

‍

## 异常处理

返回错误标志其实并不方便：人们未必会检查错误——部分原因是，如果他们要检查所有的错误值，程序就会变得极为复杂

C++具有的异常处理机制。可以用来说明程序出现了不应该忽视的错误，用户如果原因可以进行检查。
